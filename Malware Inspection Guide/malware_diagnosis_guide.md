# Linux 시스템 악성코드 진단 도구 가이드

## 개요

본 문서는 한국인터넷진흥원(KISA) 가이드라인을 기반으로 개발된 Linux 시스템 악성코드 진단 스크립트에 대한 상세 설명서입니다. 실제 스크립트 코드와 함께 각 점검 항목의 동작 방식을 설명하여 이해도를 높이고자 합니다.

## 스크립트 구조 및 초기 설정

### 기본 설정
```bash
#!/bin/bash

# 색상 코드 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# 결과 카운터 초기화
CRITICAL_COUNT=0
WARNING_COUNT=0
SAFE_COUNT=0
```

**설명**: 스크립트의 가독성을 위한 색상 코드 정의와 각 위험도별 발견 항목 수를 추적하기 위한 카운터를 초기화합니다.

### 결과 출력 함수
```bash
print_result() {
    local status=$1
    local message=$2
    if [ "$status" = "SAFE" ]; then
        echo -e "${GREEN}✓ SAFE: $message${NC}"
        SAFE_COUNT=$((SAFE_COUNT + 1))
    elif [ "$status" = "WARNING" ]; then
        echo -e "${YELLOW}⚠ WARNING: $message${NC}"
        WARNING_COUNT=$((WARNING_COUNT + 1))
    elif [ "$status" = "CRITICAL" ]; then
        echo -e "${RED}✗ CRITICAL: $message${NC}"
        CRITICAL_COUNT=$((CRITICAL_COUNT + 1))
    else
        echo -e "${CYAN}ℹ INFO: $message${NC}"
    fi
}
```

**설명**: 각 점검 결과를 위험도별로 색상과 아이콘을 사용하여 시각적으로 구분하고, 동시에 해당 위험도의 카운터를 증가시킵니다.

## 주요 진단 항목

### 1. 악성코드 뮤텍스/락(Mutex/Lock) 파일 점검

악성코드는 중복 실행을 방지하기 위해 뮤텍스나 락 파일을 생성하는 특성을 가지고 있습니다.

#### 1-1. 크기가 0인 PID 파일 점검
```bash
echo "1-1. 크기가 0인 PID 파일 점검..."
ZERO_PID_FILES=$(sudo ls -l /var/run/*.pid 2>/dev/null | awk '$5 == 0 {print $9}')
if [ -z "$ZERO_PID_FILES" ]; then
    print_result "SAFE" "크기가 0인 PID 파일이 발견되지 않았습니다"
else
    print_result "WARNING" "크기가 0인 PID 파일 발견: $ZERO_PID_FILES"
fi
```

**코드 분석**:
- `ls -l /var/run/*.pid`: PID 파일들의 상세 정보 조회
- `awk '$5 == 0 {print $9}'`: 5번째 필드(파일 크기)가 0인 경우 9번째 필드(파일명) 출력
- **위험도**: `WARNING` - 정상적인 PID 파일은 프로세스 ID를 포함해야 함

#### 1-2. 크기가 0인 LOCK 파일 점검
```bash
echo "1-2. 크기가 0인 LOCK 파일 점검..."
ZERO_LOCK_FILES=$(sudo ls -l /var/run/*.lock 2>/dev/null | awk '$5 == 0 {print $9}')
if [ -z "$ZERO_LOCK_FILES" ]; then
    print_result "SAFE" "크기가 0인 LOCK 파일이 발견되지 않았습니다"
else
    print_result "WARNING" "크기가 0인 LOCK 파일 발견: $ZERO_LOCK_FILES"
fi
```

**코드 분석**: PID 파일과 동일한 로직으로 LOCK 파일들을 검사합니다.

#### 1-3. 권한 644이면서 크기가 0인 파일 점검
```bash
echo "1-3. 권한 644이면서 크기가 0인 파일 점검..."
SUSPICIOUS_FILES=$(sudo stat -c "%a %s %n" /var/run/*.pid /var/run/*.lock 2>/dev/null | awk '$1=="644" && $2==0 { print $3 }')
if [ -z "$SUSPICIOUS_FILES" ]; then
    print_result "SAFE" "의심스러운 권한/크기 조합의 파일이 발견되지 않았습니다"
else
    print_result "CRITICAL" "의심스러운 파일 발견: $SUSPICIOUS_FILES"
fi
```

**코드 분석**:
- `stat -c "%a %s %n"`: 파일의 권한(%a), 크기(%s), 이름(%n) 출력
- `awk '$1=="644" && $2==0'`: 권한이 644이면서 크기가 0인 파일 필터링
- **위험도**: `CRITICAL` - 이는 악성코드의 전형적인 뮤텍스 패턴

### 2. 악성코드 자동 실행 파일 점검

#### 2-1. /etc/sysconfig/ 내 자동 실행 스크립트 점검
```bash
echo "2-1. /etc/sysconfig/ 내 자동 실행 스크립트 점검..."
AUTO_EXEC_FILES=$(sudo grep -Er '\[\s*-f\s+/[^]]+\]\s*&&\s*/' /etc/sysconfig/ 2>/dev/null)
if [ -z "$AUTO_EXEC_FILES" ]; then
    # 호환성 이슈 대응을 위한 대체 명령어 실행
    AUTO_EXEC_FILES=$(sudo find /etc/sysconfig/ -type f -exec egrep '\[\s*-f\s+/[^]]+\]\s*&&\s*/' {} + 2>/dev/null)
fi

if [ -z "$AUTO_EXEC_FILES" ]; then
    print_result "SAFE" "/etc/sysconfig/ 내 의심스러운 자동 실행 스크립트가 발견되지 않았습니다"
else
    print_result "CRITICAL" "의심스러운 자동 실행 스크립트 발견:"
    echo "$AUTO_EXEC_FILES"
fi
```

**코드 분석**:
- 정규식 `\[\s*-f\s+/[^]]+\]\s*&&\s*/`: `[ -f /경로/파일 ] && /실행파일` 패턴 탐지
- **호환성 고려**: `grep -Er`이 지원되지 않는 시스템을 위한 대체 명령어 제공
- **위험도**: `CRITICAL` - 파일 존재 확인 후 실행하는 패턴은 악성코드의 일반적인 은닉 방법

### 3. BPF(Berkeley Packet Filter) 점검

#### 3-1. 서버에 등록된 BPF 필터 확인
```bash
echo "3-1. 서버에 등록된 BPF 필터 확인..."
BPF_FILTERS=$(sudo ss -0pb 2>/dev/null)
if [ -z "$BPF_FILTERS" ]; then
    print_result "INFO" "활성화된 BPF 필터가 없습니다"
else
    print_result "INFO" "BPF 필터가 활성화되어 있습니다"
    echo "활성 BPF 필터 목록:"
    echo "$BPF_FILTERS" | head -10  # 첫 10줄만 표시
    if [ $(echo "$BPF_FILTERS" | wc -l) -gt 10 ]; then
        echo "... (더 많은 항목이 있습니다)"
    fi
fi
```

**코드 분석**:
- `ss -0pb`: BPF 필터가 적용된 소켓 정보 조회
- 결과가 많을 경우 처음 10개만 표시하여 가독성 확보

#### 3-2. BPF 필터 내 악성코드 매직넘버 점검
```bash
echo "3-2. BPF 필터 내 악성코드 매직넘버 점검..."
MAGIC_NUMBERS=$(sudo ss -0pb 2>/dev/null | grep -E "21139|29269|960051513|36204|40783")
if [ -z "$MAGIC_NUMBERS" ]; then
    # 대체 방법으로 16진수 매직넘버 점검
    MAGIC_NUMBERS_HEX=$(sudo ss -0pb 2>/dev/null | grep -EB1 "$((0x5293))|$((0x7255))|$((0x39393939))|$((0x8D6C))|$((0x9F4F))" 2>/dev/null)
    if [ -z "$MAGIC_NUMBERS_HEX" ]; then
        print_result "SAFE" "알려진 악성코드 매직넘버가 발견되지 않았습니다"
    else
        print_result "CRITICAL" "악성코드 매직넘버 패턴 발견:"
        echo "$MAGIC_NUMBERS_HEX"
    fi
else
    print_result "CRITICAL" "악성코드 매직넘버 발견:"
    echo "$MAGIC_NUMBERS"
fi
```

**코드 분석**:
- **탐지 대상 매직넘버**:
  - `21139` (0x5293): 특정 악성코드 패밀리 식별자
  - `29269` (0x7255): 네트워크 백도어 관련 상수
  - `960051513` (0x39393939): 데이터 인코딩 관련 상수
- **이중 검사**: 10진수와 16진수 형태 모두 검사하여 탐지 정확도 향상

### 4. 특정 포트 확인 및 네트워크 점검

#### 4-1. 전체 네트워크 연결 상태 확인
```bash
echo "4-1. 전체 네트워크 연결 상태 확인..."
NETWORK_STATUS=$(sudo netstat -tulpn 2>/dev/null)
if [ -z "$NETWORK_STATUS" ]; then
    print_result "WARNING" "네트워크 상태를 확인할 수 없습니다"
else
    print_result "INFO" "네트워크 연결 상태가 확인되었습니다"
    ACTIVE_CONNECTIONS=$(echo "$NETWORK_STATUS" | wc -l)
    echo "활성 네트워크 연결 수: $ACTIVE_CONNECTIONS"
fi
```

#### 4-2. 의심스러운 포트 범위 점검
```bash
echo "4-2. 의심스러운 포트 범위 점검 (42391-43390, 8000)..."
SUSPICIOUS_PORTS=$(sudo netstat -tulpn 2>/dev/null | awk '{match($0, /:([0-9]+)/, a); if ((a[1] >= 42391 && a[1] <= 43390) || $0 ~ /:8000([^0-9]|$)/) print $0}')
if [ -z "$SUSPICIOUS_PORTS" ]; then
    print_result "SAFE" "의심스러운 포트 범위에서 활성 연결이 발견되지 않았습니다"
else
    print_result "CRITICAL" "의심스러운 포트에서 활성 연결 발견:"
    echo "$SUSPICIOUS_PORTS"
fi
```

**코드 분석**:
- `match($0, /:([0-9]+)/, a)`: 포트 번호를 정규식으로 추출
- **검사 포트**:
  - `42391-43390`: 특정 악성코드 패밀리의 C&C 통신 포트
  - `8000`: 웹 백도어로 자주 사용되는 포트

#### 4-3. TCP 연결 상세 분석
```bash
echo "4-3. TCP 연결 상세 분석..."
TCP_ANALYSIS=$(sudo netstat -tulpn 2>/dev/null | awk '$1=="tcp"&&($6=="LISTEN"||$6=="ESTABLISHED"){lp=substr($4,index($4,":")+1);rp=substr($5,index($5,":")+1);if((lp>=42391&&lp<=43390)||lp==8000||(rp>=42391&&rp<=43390)||rp==8000)print}')
if [ -z "$TCP_ANALYSIS" ]; then
    print_result "SAFE" "의심스러운 TCP 연결이 발견되지 않았습니다"
else
    print_result "CRITICAL" "의심스러운 TCP 연결 발견:"
    echo "$TCP_ANALYSIS"
fi
```

**코드 분석**:
- `substr($4,index($4,":")+1)`: 로컬 포트 추출
- `substr($5,index($5,":")+1)`: 원격 포트 추출
- LISTEN과 ESTABLISHED 상태만 검사하여 실제 활성 연결 탐지

### 5. 실행중인 프로세스명 점검

```bash
echo "5-1. 알려진 악성 프로세스 패턴 점검..."
MALICIOUS_PROCESSES=$(sudo ps -ef | grep -E '/usr/sbin/abrtd|/sbin/udevd|cmathreshd|/sbin/sgaSolAgent|/usr/sbin/atd|pickup' | grep -v grep)
if [ -z "$MALICIOUS_PROCESSES" ]; then
    print_result "SAFE" "알려진 악성 프로세스 패턴이 발견되지 않았습니다"
else
    print_result "CRITICAL" "의심스러운 프로세스 발견:"
    echo "$MALICIOUS_PROCESSES"
fi
```

**코드 분석**:
- **검사 대상 프로세스**:
  - `/usr/sbin/abrtd`: 시스템 크래시 리포터로 위장
  - `/sbin/udevd`: 장치 관리자로 위장
  - `cmathreshd`: 사용자 정의 데몬으로 위장
  - `/sbin/sgaSolAgent`: Oracle 관련 에이전트로 위장
  - `/usr/sbin/atd`: at 스케줄러로 위장
  - `pickup`: 메일 시스템 컴포넌트로 위장
- `grep -v grep`: grep 프로세스 자체를 결과에서 제외

## 진단 결과 요약

### 요약 출력 코드
```bash
echo -e "${CYAN}═══ 진단 결과 요약 ═══${NC}"
echo -e "위험 (Critical): ${RED}$CRITICAL_COUNT개${NC}"
echo -e "경고 (Warning): ${YELLOW}$WARNING_COUNT개${NC}"
echo -e "안전 (Safe): ${GREEN}$SAFE_COUNT개${NC}"

# 전체 위험도 평가
if [ $CRITICAL_COUNT -gt 0 ]; then
    OVERALL_RISK="HIGH"
    RISK_COLOR=$RED
elif [ $WARNING_COUNT -gt 0 ]; then
    OVERALL_RISK="MEDIUM"
    RISK_COLOR=$YELLOW
else
    OVERALL_RISK="LOW"
    RISK_COLOR=$GREEN
fi

echo -e "\n전체 위험도: ${RISK_COLOR}$OVERALL_RISK${NC}"
```

**설명**: 각 위험도별 항목 수를 집계하여 전체적인 시스템 보안 상태를 평가합니다.

## 위험도별 권장사항

### HIGH 위험도 시 권장사항
```bash
if [ $CRITICAL_COUNT -gt 0 ] || [ $WARNING_COUNT -gt 0 ]; then
    echo
    print_header "권장사항"
    echo -e "${YELLOW}⚠ 시스템에서 보안 위험 요소가 발견되었습니다.${NC}"
    echo -e "${YELLOW}1. 즉시 보안 담당자에게 보고하시기 바랍니다.${NC}"
    echo -e "${YELLOW}2. 의심스러운 프로세스나 파일에 대한 추가 조사가 필요합니다.${NC}"
    echo -e "${YELLOW}3. 시스템 격리 및 포렌식 분석을 고려하시기 바랍니다.${NC}"
    echo -e "${YELLOW}4. 모든 사용자 계정과 권한을 재검토하시기 바랍니다.${NC}"
    echo -e "${YELLOW}5. 방화벽 규칙과 네트워크 접근 제어를 강화하시기 바랍니다.${NC}"
else
    echo
    print_header "진단 완료"
    echo -e "${GREEN}✓ 현재 시스템에서 알려진 악성코드 징후가 발견되지 않았습니다.${NC}"
    echo -e "${GREEN}✓ 하지만 정기적인 보안 점검을 계속 수행하시기 바랍니다.${NC}"
fi
```

## 스크립트 실행 방법

```bash
# 실행 권한 부여
chmod +x malware_diagnosis_script.sh

# 스크립트 실행
sudo ./malware_diagnosis_script.sh
```

## 주요 특징

1. **KISA 가이드라인 준수**: 국내 사이버보안 표준에 맞춘 점검 항목
2. **호환성 고려**: 다양한 Linux 배포판에서 동작하도록 대체 명령어 제공
3. **시각적 피드백**: 색상과 아이콘을 통한 직관적인 결과 표시
4. **자동화된 분석**: 수동 점검의 번거로움을 해소한 종합적 진단
5. **실시간 집계**: 각 위험도별 항목 수를 실시간으로 추적

이 스크립트는 Linux 시스템에서 알려진 악성코드 감염 징후를 체계적으로 탐지하는 종합적인 보안 점검 도구로, 정기적인 실행을 통해 시스템 보안 상태를 효과적으로 모니터링할 수 있습니다.